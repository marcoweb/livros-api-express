"use strict";
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withDefaultAuth = withDefaultAuth;
const cross_1 = require("../../cross");
const proxy_1 = require("./proxy");
const utils_1 = require("./utils");
/**
 * Gets an enhanced Prisma client that supports `@default(auth())` attribute.
 *
 * @private
 */
function withDefaultAuth(prisma, options, context = {}) {
    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new DefaultAuthHandler(_prisma, model, options, context), 'defaultAuth');
}
class DefaultAuthHandler extends proxy_1.DefaultPrismaProxyHandler {
    constructor(prisma, model, options, context) {
        super(prisma, model, options);
        this.context = context;
        this.userContext = this.context.user;
    }
    // base override
    preprocessArgs(action, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const actionsOfInterest = [
                'create',
                'createMany',
                'createManyAndReturn',
                'update',
                'updateMany',
                'upsert',
            ];
            if (actionsOfInterest.includes(action)) {
                const newArgs = yield this.preprocessWritePayload(this.model, action, args);
                return newArgs;
            }
            return args;
        });
    }
    preprocessWritePayload(model, action, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const newArgs = (0, cross_1.clone)(args);
            const processCreatePayload = (model, data) => {
                const fields = (0, cross_1.getFields)(this.options.modelMeta, model);
                for (const fieldInfo of Object.values(fields)) {
                    if (fieldInfo.isTypeDef) {
                        this.setDefaultValueForTypeDefData(fieldInfo.type, data[fieldInfo.name]);
                        continue;
                    }
                    if (fieldInfo.name in data) {
                        // create payload already sets field value
                        continue;
                    }
                    if (!fieldInfo.defaultValueProvider) {
                        // field doesn't have a runtime default value provider
                        continue;
                    }
                    const defaultValue = this.getDefaultValue(fieldInfo);
                    if (defaultValue !== undefined) {
                        // set field value extracted from `auth()`
                        this.setDefaultValueForModelData(fieldInfo, model, data, defaultValue);
                    }
                }
            };
            // visit create payload and set default value to fields using `auth()` in `@default()`
            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {
                create: (model, data) => {
                    processCreatePayload(model, data);
                },
                upsert: (model, data) => {
                    processCreatePayload(model, data.create);
                },
                createMany: (model, args) => {
                    for (const item of (0, cross_1.enumerate)(args.data)) {
                        processCreatePayload(model, item);
                    }
                },
            });
            yield visitor.visit(model, action, newArgs);
            return newArgs;
        });
    }
    setDefaultValueForModelData(fieldInfo, model, data, authDefaultValue) {
        var _a;
        if (fieldInfo.isForeignKey && fieldInfo.relationField && fieldInfo.relationField in data) {
            // if the field is a fk, and the relation field is already set, we should not override it
            return;
        }
        if (fieldInfo.isForeignKey && !(0, utils_1.isUnsafeMutate)(model, data, this.options.modelMeta)) {
            // if the field is a fk, and the create payload is not unsafe, we need to translate
            // the fk field setting to a `connect` of the corresponding relation field
            const relFieldName = fieldInfo.relationField;
            if (!relFieldName) {
                throw new Error(`Field \`${fieldInfo.name}\` is a foreign key field but no corresponding relation field is found`);
            }
            const relationField = (0, cross_1.requireField)(this.options.modelMeta, model, relFieldName);
            // construct a `{ connect: { ... } }` payload
            let connect = (_a = data[relationField.name]) === null || _a === void 0 ? void 0 : _a.connect;
            if (!connect) {
                connect = {};
                data[relationField.name] = { connect };
            }
            // sets the opposite fk field to value `authDefaultValue`
            const oppositeFkFieldName = this.getOppositeFkFieldName(relationField, fieldInfo);
            if (!oppositeFkFieldName) {
                throw new Error(`Cannot find opposite foreign key field for \`${fieldInfo.name}\` in relation field \`${relFieldName}\``);
            }
            connect[oppositeFkFieldName] = authDefaultValue;
        }
        else {
            // set default value directly
            data[fieldInfo.name] = authDefaultValue;
        }
    }
    getOppositeFkFieldName(relationField, fieldInfo) {
        if (!relationField.foreignKeyMapping) {
            return undefined;
        }
        const entry = Object.entries(relationField.foreignKeyMapping).find(([, v]) => v === fieldInfo.name);
        return entry === null || entry === void 0 ? void 0 : entry[0];
    }
    getDefaultValue(fieldInfo) {
        var _a;
        if (!this.userContext) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Evaluating default value of field \`${fieldInfo.name}\` requires a user context`);
        }
        return (_a = fieldInfo.defaultValueProvider) === null || _a === void 0 ? void 0 : _a.call(fieldInfo, this.userContext);
    }
    setDefaultValueForTypeDefData(type, data) {
        if (!data || (typeof data !== 'object' && !Array.isArray(data))) {
            return;
        }
        const typeDef = (0, cross_1.getTypeDefInfo)(this.options.modelMeta, type);
        if (!typeDef) {
            return;
        }
        (0, cross_1.enumerate)(data).forEach((item) => {
            if (!item || typeof item !== 'object') {
                return;
            }
            for (const fieldInfo of Object.values(typeDef.fields)) {
                if (fieldInfo.isTypeDef) {
                    // recurse
                    this.setDefaultValueForTypeDefData(fieldInfo.type, item[fieldInfo.name]);
                }
                else if (!(fieldInfo.name in item)) {
                    // set default value if the payload doesn't set the field
                    const defaultValue = this.getDefaultValue(fieldInfo);
                    if (defaultValue !== undefined) {
                        item[fieldInfo.name] = defaultValue;
                    }
                }
            }
        });
    }
}
//# sourceMappingURL=default-auth.js.map